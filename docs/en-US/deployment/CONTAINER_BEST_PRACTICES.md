# BotMatrix Containerization & Plugin Management Best Practices

> [ç®€ä½“ä¸­æ–‡](../../zh-CN/deployment/CONTAINER_BEST_PRACTICES.md) | [ðŸŒ English](CONTAINER_BEST_PRACTICES.md)
> [â¬…ï¸ Back to Docs Center](../README.md) | [ðŸ  Back to Project Home](../../../README.md)

This document provides a best practice guide for deploying BotWorker and its plugin system in containerized environments (Docker/K8s).

## 1. Core Philosophy: Stateless Worker + Stateful Plugins

To achieve high availability and elastic scaling, BotWorker remains **Stateless**, while plugins and user session states are managed through external systems and persistent storage.

### 1.1 Architectural Diagram
```text
[ User ] -> [ Reverse Proxy (Nginx) ] 
                 |
        [ BotWorker Cluster (Replicas: N) ]
          /            |            \
 [ Redis Session ] [ Shared Storage ] [ BotNexus Center ]
    (State)         (Plugins)          (Control)
```

## 2. Plugin Management Best Practices

In containerized environments, the pain points of plugin upgrades are "update without restart" and "multi-instance synchronization".

### 2.1 Directory Structure
We recommend using a versioned directory structure, automatically scanned by `PluginManager`:
```text
/app/plugins/
  â”œâ”€â”€ weather_plugin/
  â”‚   â”œâ”€â”€ v1.0.0/ (manifest.json, main.py)
  â”‚   â””â”€â”€ v1.1.0/ (manifest.json, main.py)
  â””â”€â”€ translator_plugin/
      â””â”€â”€ v2.0.1/
```

### 2.2 Canary Release
Utilize the `canary_weight` in `PluginConfig`:
1.  **Upload New Version**: Place the new plugin version in `/app/plugins/id/new_version/`.
2.  **Set Weight**: Set `canary_weight: 10` in `plugin.json`.
3.  **Core Auto-Routing**: `PluginManager` will route 10% of traffic to the new version based on `CorrelationId` (Session Stickiness).
4.  **Full Cutover**: After verification, stop the old version and set the new version's weight to 0 (or remove the old version directory).

### 2.3 Dynamic Synchronization (Market Sync)
Plugin synchronization can be triggered via environment variables or APIs during container startup:
-   **Method A**: Mount a shared volume (NFS/Ceph/HostPath) in `docker-compose`.
-   **Method B**: Call the `SyncFromMarket(url)` API, allowing each Worker to automatically download and hot-load the plugin.

## 3. Deployment Guide

### 3.1 Dockerfile Optimization
-   **Multi-stage Build**: Reduce image size and improve startup speed.
-   **Pre-installed Runtime**: The image should include dependencies like Python, .NET Runtime, etc.
-   **Health Check**: Configure `HEALTHCHECK` to ensure faulty instances are automatically restarted.

### 3.2 Docker Compose Example
Refer to the [docker-compose.yml](../../../docker-compose.yml) in the project root. Key points:
-   Use `deploy.replicas` for horizontal scaling.
-   Use `update_config.order: start-first` for zero-downtime rolling updates.

## 4. FAQ

**Q: Does plugin upgrading require restarting the Worker container?**
A: No. `PluginManager` supports hot-loading and hot-updating. Just unzip the new plugin package to the mounted directory and call the hot-update interface.

**Q: How to ensure plugin consistency across multiple Worker instances?**
A: 
1.  **Centralized Distribution**: BotNexus sends commands, and Workers execute `SyncFromMarket` upon receiving them.
2.  **Shared Storage**: All Workers mount the same distributed file system volume.

**Q: Where should temporary files generated by plugins be placed?**
A: Never place them in the plugin directory. Use `/tmp` or a dedicated persistent `data` directory.

---
*Last Updated: 2025-12-28*
